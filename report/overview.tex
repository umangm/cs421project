\subsection{Recursion}
\hspace{0.2in} 
The use of recursion dates back to the late 19$^{th}$ century, when mathematicians Dedekind and Peano used induction to defined functions.
The use of recursion played an important role in foundations of computer science, and was later referred to as 'primitive recursion'~\cite{Soare96}

Use of recursion is not just exciting from the perspective of a Mathematician, but is also quite significant from the perspective of a developer.
Allowing procedures to be recursive helps the programmer write more readable and intuitive/natural programs.
A notable use of recursion is seen when dealing with inductive structures.
Inductive definitions and inductive programs can be very naturally programmed as recursive functions.
Besides, recursive functions, can be easier to debug, due to the same reason.
Recursive programs, at times, tend to be more efficient than a naive program with loops and no recursive calls. 
Recursion, thus is a very handy tool for programmers.

\subsection{Checking Tail Reclusion : Motivation}

\hspace{0.2in} The convenience offered due to recursion, comes at a cost. 
Recursive programs are generally modelled by the use of stack frames. 
This means that recursive programs tend to consume extra space (stack) for every recursive call they make.
Besides, the additional overhead of copying the variables and values to the new frame, also accounts for a non trivial overhead, which at times, is not desirable from the standpoint of efficiency.

However, the extra space consumed can be overcome when the recursive call is the last thing the function does. 
In this case, the contents of the stack can be replaced by the new frame, and there is no need to push an additional frame.

The idea behind tail call optimization is essentially the same. 
Informally, a recursive function is tail recursive when the recursive call is the last thing executed by the function. 
Thus, if the compiler can detect if a function is tail-recursive, it can convert the function to an equivalent while-loop, thus avoiding an additional call that consumes extra stack space by virtue of the new frame added.

\subsection{Goal of the Project}
In this project, we implement a tool \tool that checks if a procedure is tail recursive or not.
Specifically, we wish to analyze declarations written in PicoML. 
PicoML is a restricted form of OCaml, and supports simple expressions like  $\ifexp{\!}{\!}{\!}$, $\mathtt{fun}$, $\mathtt{let} \! \mathtt{rec}$. 
As part of the assignments in the course, we have built an interpreter for this language~\cite{OlderMP}.
We aim to integrate the \tool with the interpreter. 
That is, we would use the parsing and the type checking functionality written in older assignments.
This would enable use to directly use the functionality for implementing \tool, and would save some  effort, 
as compared to the scenario where we had to re-invent the wheel.